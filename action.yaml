name: 'Syncoor Test'
description: 'Run Ethereum client synchronization tests using syncoor'
author: 'ethpandaops'

inputs:
  github-token:
    description: 'GitHub token for API access' # You can just provide ${{ secrets.GITHUB_TOKEN }}
    required: true

  image:
    description: 'Docker image for syncoor (e.g., docker.ethquokkaops.io/dh/ethpandaops/syncoor:master). If not provided, will build locally.'
    required: false
    default: ''

  git-ref:
    description: 'Git branch or commit hash to build from. Only used when image is not provided. If neither image nor git-ref are provided, builds from current directory or master.'
    required: false
    default: ''

  repository:
    description: 'Git repository URL to clone from when using git-ref'
    required: false
    default: 'https://github.com/ethpandaops/syncoor.git'

  run-tests:
    description: 'Run tests. Useful for generating report index only. There you can set it to false and run the action again to generate the index.'
    required: false
    default: 'true'

  # Syncoor arguments
  check-interval:
    description: 'Interval in seconds between sync status checks'
    required: false
    default: '10s'

  run-timeout:
    description: 'Timeout for sync operation - will cancel sync and generate report marked as "timeout" if exceeded (exits with code 124, treated as success in CI)'
    required: false
    default: '60m'

  client-logs:
    description: 'Output EL and CL client logs to stdout'
    required: false
    default: 'false'

  el-client:
    description: 'Execution layer client type (geth, besu, nethermind, erigon, reth)'
    required: false
    default: 'geth'

  cl-client:
    description: 'Consensus layer client type (lighthouse, teku, prysm, nimbus, lodestar, grandine)'
    required: false
    default: 'teku'

  el-image:
    description: 'Execution layer client image (optional)'
    required: false
    default: ''

  cl-image:
    description: 'Consensus layer client image (optional)'
    required: false
    default: ''

  el-extra-args:
    description: 'Extra arguments for execution layer client (optional)'
    required: false
    default: ''

  cl-extra-args:
    description: 'Extra arguments for consensus layer client (optional)'
    required: false
    default: ''

  network:
    description: 'Network to connect to (e.g., hoodi, sepolia, mainnet)'
    required: false
    default: 'hoodi'

  enclave:
    description: 'Enclave name (optional - defaults to "sync-test"'
    required: false
    default: 'sync-test'

  log-level:
    description: 'Log level (panic, fatal, error, warn, info, debug, trace)'
    required: false
    default: 'info'

  log-force-colors:
    description: 'Force colored output in logs'
    required: false
    default: 'false'


  labels:
    description: 'Comma-separated labels in key=value format (e.g., "test=sync,env=ci")'
    required: false
    default: ''

  server:
    description: 'Centralized server URL (e.g., https://api.syncoor.example)'
    required: false
    default: ''

  server-auth:
    description: 'Bearer token for server authentication'
    required: false
    default: ''

  # Ethereum network configuration
  supernode:
    description: 'Enable supernode (should only be used with peerdas)'
    required: false
    default: 'false'

  checkpoint-sync-enabled:
    description: 'Enable checkpoint sync across the network'
    required: false
    default: 'true'

  checkpoint-sync-url:
    description: 'Checkpoint sync URL (e.g., https://checkpoint-sync.sepolia.ethpandaops.io/)'
    required: false
    default: ''

  # Public port configuration
  public:
    description: 'Enable public port publishing'
    required: false
    default: 'false'

  public-port-el:
    description: 'Public port for execution layer client'
    required: false
    default: '40000'

  public-port-cl:
    description: 'Public port for consensus layer client'
    required: false
    default: '41000'

  public-ip:
    description: 'Public IP for port publishing (default: auto)'
    required: false
    default: 'auto'

  # Client log levels
  log-level-el:
    description: 'Log level for execution layer client (trace, debug, info, warn, error)'
    required: false
    default: 'info'

  log-level-cl:
    description: 'Log level for consensus layer client (trace, debug, info, warn, error)'
    required: false
    default: 'info'

  # Github artifacts upload
  upload-artifacts:
    description: 'Whether to upload test reports as artifacts'
    required: false
    default: 'true'

  artifact-retention-days-test-report:
    description: 'Number of days to retain test report artifacts'
    required: false
    default: '30'

  artifact-retention-days-enclave-dump:
    description: 'Number of days to retain enclave dump artifacts'
    required: false
    default: '7'

  ## S3 upload using rclone
  s3-upload:
    description: 'Upload test results to S3'
    required: false
    default: 'false'

  s3-bucket:
    description: 'S3 bucket name'
    required: false

  s3-path:
    description: 'Path prefix in S3 bucket'
    required: false
    default: ''

  s3-index-generate:
    description: 'Generate index.json file in S3 bucket after test run'
    required: false
    default: 'false'

  rclone-config:
    description: 'Rclone config file'
    required: false
    default: '' # Should be base64 encoded. Example: base64 -w 0 rclone.conf

  rclone-version:
    description: 'Rclone version to use'
    required: false
    default: 'latest'

outputs:
  report-path:
    description: 'Path to the generated report'
    value: ${{ steps.run-test.outputs.report-path }}
  main-report-file:
    description: 'Name of the main report JSON file (without .json extension)'
    value: ${{ steps.run-test.outputs.main-report-file }}

runs:
  using: 'composite'
  steps:
    - name: Verify and install dependencies
      if: ${{ inputs.run-tests == 'true' }}
      uses: ethpandaops/syncoor/.github/actions/dependencies@b64b2368935a1a9f552efac7ed5cebd1820ddf60

    - name: Build Syncoor Docker image locally
      if: inputs.image == ''
      shell: bash
      run: |
        # Determine git ref to use
        GIT_REF="${{ inputs.git-ref }}"
        if [ -z "$GIT_REF" ]; then
          GIT_REF="master"
        fi

        # Clone from specified git ref (defaults to master)
        echo "Cloning repository from ${{ inputs.repository }} at ref $GIT_REF"
        git clone ${{ inputs.repository }} syncoor-build
        cd syncoor-build
        git checkout $GIT_REF

        # Build the Docker image
        echo "Building Docker image..."
        docker build -t syncoor:local .
        cd ..

        # Clean up
        rm -rf syncoor-build

    - name: Setup Rclone for S3 upload
      if: ${{ inputs.s3-upload == 'true' }}
      uses: AnimMouse/setup-rclone@0d99fa3878a334d3e307c1a8372ad55550fdaea7 # v1.11.0
      with:
        rclone_config: ${{ inputs.rclone-config }}
        version: ${{ inputs.rclone-version }}

    - name: Check S3 connectivity before running test
      if: ${{ inputs.s3-upload == 'true' }}
      shell: bash
      run: |
        rclone touch s3:${{ inputs.s3-bucket }}/${{ inputs.s3-path }}/healthcheck.txt

    - name: Make sure kurtosis engine is started
      if: ${{ inputs.run-tests == 'true' }}
      id: engine-start
      shell: bash
      run: |
        kurtosis engine start
        kurtosis engine status

    - name: Cleanup kurtosis enclaves and resources. We want a clean slate.
      if: ${{ inputs.run-tests == 'true' }}
      shell: bash
      run: |
        kurtosis clean -a

    - name: Determine which image to use
      id: determine-image
      shell: bash
      run: |
        # Use provided image if specified, otherwise default to local build
        if [ -n "${{ inputs.image }}" ]; then
          IMAGE="${{ inputs.image }}"
          echo "Using provided Docker image: ${IMAGE}"
        else
          IMAGE="syncoor:local"
          echo "No image specified, will build locally: ${IMAGE}"
        fi
        echo "image=${IMAGE}" >> $GITHUB_OUTPUT

        # Validate that we have an image
        if [ -z "$IMAGE" ]; then
          echo "ERROR: Docker image not specified"
          echo "Git ref: '${{ inputs.git-ref }}'"
          echo "Input image: '${{ inputs.image }}'"
          exit 1
        fi

        # Pull the image if it's not a local build
        if [ "$IMAGE" != "syncoor:local" ]; then
          echo "Pulling Docker image: ${IMAGE}"
          docker pull "${IMAGE}" || {
            echo "Failed to pull Docker image: ${IMAGE}"
            exit 1
          }
        fi

    - name: Get Job ID from GH API
      if: ${{ inputs.run-tests == 'true' }}
      id: get-job-id
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
      run: |
        jobs=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id}}/attempts/${{ github.run_attempt }}/jobs)
        job_id=$(echo $jobs | jq -r '.jobs[] | select(.runner_name=="${{ runner.name }}") | .id')
        echo "job_id=$job_id" >> $GITHUB_OUTPUT

    - name: Run Syncoor test
      if: ${{ inputs.run-tests == 'true' }}
      id: run-test
      shell: bash
      run: |
        IMAGE="${{ steps.determine-image.outputs.image }}"
        echo "Running syncoor test with Docker image: ${IMAGE}"

        # Build docker run command
        DOCKER_CMD="docker run --platform linux/amd64 --network=host --rm --name=syncoor-run -u $(id -u):$(id -g)"

        # Add Docker socket mount for Kurtosis
        DOCKER_CMD="$DOCKER_CMD -v /var/run/docker.sock:/var/run/docker.sock"

        # Mount report directory
        DOCKER_CMD="$DOCKER_CMD -v ${{ runner.temp }}/reports:/app/reports"

        # Add the image
        DOCKER_CMD="$DOCKER_CMD $IMAGE"

        # Use 'sync' command
        DOCKER_CMD="$DOCKER_CMD sync"

        # Add CLI flags
        DOCKER_CMD="$DOCKER_CMD --check-interval=${{ inputs.check-interval }}"
        DOCKER_CMD="$DOCKER_CMD --run-timeout=${{ inputs.run-timeout }}"
        DOCKER_CMD="$DOCKER_CMD --el-client=${{ inputs.el-client }}"
        DOCKER_CMD="$DOCKER_CMD --cl-client=${{ inputs.cl-client }}"
        DOCKER_CMD="$DOCKER_CMD --network=${{ inputs.network }}"
        DOCKER_CMD="$DOCKER_CMD --report-dir=/app/reports"
        DOCKER_CMD="$DOCKER_CMD --log-level=${{ inputs.log-level }}"
        DOCKER_CMD="$DOCKER_CMD --enclave=${{ inputs.enclave }}"
        DOCKER_CMD="$DOCKER_CMD --log-force-colors=${{ inputs.log-force-colors }}"
        DOCKER_CMD="$DOCKER_CMD --client-logs=${{ inputs.client-logs }}"

        # Add optional parameters if provided
        if [ -n "${{ inputs.el-image }}" ]; then
          DOCKER_CMD="$DOCKER_CMD --el-image=${{ inputs.el-image }}"
        fi

        if [ -n "${{ inputs.cl-image }}" ]; then
          DOCKER_CMD="$DOCKER_CMD --cl-image=${{ inputs.cl-image }}"
        fi

        if [ -n "${{ inputs.el-extra-args }}" ]; then
          DOCKER_CMD="$DOCKER_CMD --el-extra-args=\"${{ inputs.el-extra-args }}\""
        fi

        if [ -n "${{ inputs.cl-extra-args }}" ]; then
          DOCKER_CMD="$DOCKER_CMD --cl-extra-args=\"${{ inputs.cl-extra-args }}\""
        fi

        # Add GitHub Actions context labels for traceability
        DOCKER_CMD="$DOCKER_CMD --label=github.run_id=${{ github.run_id }}"
        DOCKER_CMD="$DOCKER_CMD --label=github.run_number=${{ github.run_number }}"
        DOCKER_CMD="$DOCKER_CMD --label=github.job=${{ github.job }}"
        DOCKER_CMD="$DOCKER_CMD --label=github.job_id=${{ steps.get-job-id.outputs.job_id }}"
        DOCKER_CMD="$DOCKER_CMD --label=github.repository=${{ github.repository }}"
        DOCKER_CMD="$DOCKER_CMD --label=github.workflow=\"${{ github.workflow }}\""
        DOCKER_CMD="$DOCKER_CMD --label=github.sha=${{ github.sha }}"
        DOCKER_CMD="$DOCKER_CMD --label=github.actor=${{ github.actor }}"
        DOCKER_CMD="$DOCKER_CMD --label=github.event_name=${{ github.event_name }}"
        DOCKER_CMD="$DOCKER_CMD --label=github.ref=${{ github.ref }}"

        # Add user-provided labels if provided
        if [ -n "${{ inputs.labels }}" ]; then
          IFS=',' read -ra LABEL_ARRAY <<< "${{ inputs.labels }}"
          for label in "${LABEL_ARRAY[@]}"; do
            DOCKER_CMD="$DOCKER_CMD --label=$label"
          done
        fi

        # Add server parameters if provided
        if [ -n "${{ inputs.server }}" ]; then
          DOCKER_CMD="$DOCKER_CMD --server=\"${{ inputs.server }}\""
        fi

        if [ -n "${{ inputs.server-auth }}" ]; then
          DOCKER_CMD="$DOCKER_CMD --server-auth=\"${{ inputs.server-auth }}\""
        fi

        # Add Ethereum network configuration parameters
        if [ "${{ inputs.supernode }}" = "true" ]; then
          DOCKER_CMD="$DOCKER_CMD --supernode"
        fi

        if [ "${{ inputs.checkpoint-sync-enabled }}" = "true" ]; then
          DOCKER_CMD="$DOCKER_CMD --checkpoint-sync-enabled"
        else
          DOCKER_CMD="$DOCKER_CMD --checkpoint-sync-enabled=false"
        fi

        if [ -n "${{ inputs.checkpoint-sync-url }}" ]; then
          DOCKER_CMD="$DOCKER_CMD --checkpoint-sync-url=\"${{ inputs.checkpoint-sync-url }}\""
        fi

        # Add public port configuration parameters
        if [ "${{ inputs.public }}" = "true" ]; then
          DOCKER_CMD="$DOCKER_CMD --public"
          DOCKER_CMD="$DOCKER_CMD --public-port-el=${{ inputs.public-port-el }}"
          DOCKER_CMD="$DOCKER_CMD --public-port-cl=${{ inputs.public-port-cl }}"
          DOCKER_CMD="$DOCKER_CMD --public-ip=\"${{ inputs.public-ip }}\""
        fi

        # Add client log level parameters
        DOCKER_CMD="$DOCKER_CMD --log-level-el=${{ inputs.log-level-el }}"
        DOCKER_CMD="$DOCKER_CMD --log-level-cl=${{ inputs.log-level-cl }}"

        # Execute the command
        echo "Running: $DOCKER_CMD"
        set +e  # Disable exit on error so we can handle the exit code ourselves
        eval $DOCKER_CMD &
        wait $!
        DOCKER_EXIT_CODE=$?
        set -e  # Re-enable exit on error for the rest of the script

        # Find the generated main.json file (may not exist if test was interrupted)
        MAIN_JSON_FILE=""
        if [ -d "${{ runner.temp }}/reports" ]; then
          MAIN_JSON_PATH=$(find ${{ runner.temp }}/reports -name "*.main.json" -type f | head -1)
          if [ -n "$MAIN_JSON_PATH" ]; then
            MAIN_JSON_FILE=$(basename "$MAIN_JSON_PATH" .json)
          fi
        fi

        # Set outputs (always set report-path, main-report-file may be empty)
        echo "report-path=${{ runner.temp }}/reports" >> $GITHUB_OUTPUT
        echo "main-report-file=$MAIN_JSON_FILE" >> $GITHUB_OUTPUT

        # Handle exit codes appropriately
        if [ $DOCKER_EXIT_CODE -eq 0 ]; then
          echo "✅ Syncoor test completed successfully"
          exit 0
        elif [ $DOCKER_EXIT_CODE -eq 124 ]; then
          echo "⏰ Syncoor test timed out (exit code 124) - this is acceptable for CI"
          echo "The test will be marked as successful since timeout is expected behavior"
          exit 0
        else
          echo "❌ Syncoor test failed with exit code $DOCKER_EXIT_CODE"
          echo "This indicates an actual error that should fail the CI job"
          exit $DOCKER_EXIT_CODE
        fi

    - name: Upload results to S3
      if: ${{ inputs.s3-upload == 'true' && inputs.run-tests == 'true' }}
      shell: bash
      run: |
        rclone copy --no-traverse ${{ runner.temp }}/reports s3:${{ inputs.s3-bucket }}/${{ inputs.s3-path }}

    - name: Generate report index and upload to S3
      if: ${{ inputs.s3-upload == 'true' && inputs.s3-index-generate == 'true' }}
      shell: bash
      run: |
        echo "Fetching results from S3"
        rclone copy --progress --transfers=100 --include "*.main.json" s3://${{ inputs.s3-bucket }}/${{ inputs.s3-path }} ${{ github.workspace }}/tmp_results

        IMAGE="${{ steps.determine-image.outputs.image }}"
        echo "Using Docker image for report index generation: ${IMAGE}"

        # Build docker run command
        DOCKER_CMD="docker run --platform linux/amd64 --rm --name=syncoor-index -u $(id -u):$(id -g)"

        # Mount report directory
        DOCKER_CMD="$DOCKER_CMD -v ${{ github.workspace }}/tmp_results:/app/reports"

        # Add the image
        DOCKER_CMD="$DOCKER_CMD $IMAGE"

        # Use 'report-index' command
        DOCKER_CMD="$DOCKER_CMD report-index --report-dir /app/reports --output /app/reports/index.json"

        # Execute the command
        echo "Running: $DOCKER_CMD"
        eval $DOCKER_CMD &
        wait $!

        echo "Upload index.json file to S3"
        rclone copy ${{ github.workspace }}/tmp_results/index.json s3:${{ inputs.s3-bucket }}/${{ inputs.s3-path }}/

    - name: Upload test reports
      uses: actions/upload-artifact@v4
      if: always() && inputs.upload-artifacts == 'true' && inputs.run-tests == 'true'
      with:
        name: ${{ inputs.network }}-${{ inputs.el-client }}-${{ inputs.cl-client }}-sync-report
        path: ${{ runner.temp }}/reports
        retention-days: ${{ inputs.artifact-retention-days-test-report }}

    - name: Get kurtosis enclave dump
      if: always() && inputs.upload-artifacts == 'true' && inputs.run-tests == 'true'
      id: enclave-dump
      shell: bash
      run: |
        kurtosis enclave dump ${{ inputs.enclave }} kurtosis-enclave-dump

    - name: Upload enclave dump as github artifact
      uses: actions/upload-artifact@v4
      if: always() && inputs.upload-artifacts == 'true' && inputs.run-tests == 'true'
      with:
        name: ${{ inputs.network }}-${{ inputs.el-client }}-${{ inputs.cl-client }}-kurtosis-enclave-dump
        path: kurtosis-enclave-dump
        retention-days: ${{ inputs.artifact-retention-days-enclave-dump }}

    - name: Upload enclave dump to S3
      if: >
        inputs.s3-upload == 'true' &&
        inputs.run-tests == 'true' &&
        steps.run-test.outputs.main-report-file != '' &&
        steps.run-test.outputs.main-report-file != null
      shell: bash
      run: |
        echo "Uploading enclave dump to S3"
        set -x
        filename="${{ steps.run-test.outputs.main-report-file }}.dump.zip"
        cd kurtosis-enclave-dump
        zip -r ../$filename .
        cd ..
        rclone copy $filename s3:${{ inputs.s3-bucket }}/${{ inputs.s3-path }}/

    - name: Generate report markdown for Github Actions summary
      if: steps.run-test.outputs.main-report-file != '' && steps.run-test.outputs.main-report-file != null
      shell: bash
      run: |
        IMAGE="${{ steps.determine-image.outputs.image }}"
        echo "Using Docker image for markdown generation: ${IMAGE}"

        # Build docker run command
        DOCKER_CMD="docker run --platform linux/amd64 --rm --name=syncoor-md -u $(id -u):$(id -g)"

        # Mount report file
        DOCKER_CMD="$DOCKER_CMD -v ${{ runner.temp }}/reports:/app/reports"

        # Add the image
        DOCKER_CMD="$DOCKER_CMD $IMAGE"

        # Use 'report-to-md' command
        DOCKER_CMD="$DOCKER_CMD report-to-md"
        DOCKER_CMD="$DOCKER_CMD --input /app/reports/${{ steps.run-test.outputs.main-report-file }}.json"
        DOCKER_CMD="$DOCKER_CMD --output /app/reports/${{ steps.run-test.outputs.main-report-file }}.md"

        # Execute the command
        echo "Running: $DOCKER_CMD"
        eval $DOCKER_CMD &
        wait $!

    - name: Create GitHub Actions summary
      uses: Ma11hewThomas/github-markdown-builder@2012f2e4a8cdea69ea3f3760114a763956bff86b # v1.0.2-unreleased
      if: steps.run-test.outputs.main-report-file != '' && steps.run-test.outputs.main-report-file != null
      with:
        template-file-path: '${{ runner.temp }}/reports/${{ steps.run-test.outputs.main-report-file }}.md'
        summary: "true"
        pull-request: "false"
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
